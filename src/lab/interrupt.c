#include "pin.h"
#include <libopencm3/cm3/cortex.h>
#include <libopencm3/stm32/rcc.h>
#include <libopencm3/cm3/scb.h>
#include <libopencm3/cm3/nvic.h>
#include <libopencm3/stm32/exti.h>

const sk_pin led_green = { .port=PORTD, .pin=12, .isinverse=false};
const sk_pin led_orange = { .port=PORTD, .pin=13, .isinverse=false};
const sk_pin led_red = { .port=PORTD, .pin=14, .isinverse=false};
const sk_pin led_blue = { .port=PORTD, .pin=15, .isinverse=false};
const sk_pin us_btn = { .port=PORTA, .pin=0, .isinverse=false};

uint8_t mode = 0;

void softdelay(uint32_t N)
{
	while (N--) __asm__("nop");
}

/**
 * We need exeption.
 * The exception type is Interrupt (IRQ).
 * Interrupt (IRQ):
 *      An interrupt, or IRQ, is an exception signalled by a peripheral, or
 *      generated by a software request. All interrupts are asynchronous to
 *      instruction execution. In the system, peripherals use interrupts to
 *      communicate with the processor.
 * The Interrupts (IRQ) start from number 0 and have the priority 7 and above.
 * The processor handles exceptions using Interrupt Service
 * Routines (ISRs) Interrupts IRQ0 to IRQ81 are the exceptions handled by ISRs.
 * We took EXTI0_ISR because we used user button PA0.
 */

void leds_blinky(void)
{
        if (mode > 3)
                mode = 0;

        if (mode == 0){
                softdelay(400000);
                sk_pin_set(led_green, true);
                softdelay(400000);
                sk_pin_set(led_orange, true);
                softdelay(400000);
                sk_pin_set(led_red, true);
                softdelay(400000);
                sk_pin_set(led_blue, true);
                softdelay(400000);
                sk_pin_set(led_green, false);
                softdelay(400000);
                sk_pin_set(led_orange, false);
                softdelay(400000);
                sk_pin_set(led_red, false);
                softdelay(400000);
                sk_pin_set(led_blue, false);
        } else if (mode == 1) {
                sk_pin_set(led_green, true);
                softdelay(400000);
                sk_pin_set(led_blue, false);
                sk_pin_set(led_orange, true);
                softdelay(400000);
                sk_pin_set(led_green, false);
                sk_pin_set(led_red, true);
                softdelay(400000);
                sk_pin_set(led_orange, false);
                sk_pin_set(led_blue, true);
                softdelay(400000);
                sk_pin_set(led_red, false);
        } else if (mode == 2) {
                softdelay(400000);
                sk_pin_set(led_green, true);
                sk_pin_set(led_red, false);
                softdelay(400000);
                sk_pin_set(led_red, true);
                sk_pin_set(led_green, false);
                softdelay(400000);
                sk_pin_set(led_orange, true);
                sk_pin_set(led_blue, false);
                softdelay(400000);
                sk_pin_set(led_blue, true);
                sk_pin_set(led_orange, false);
        } else if (mode == 3) {
                softdelay(100000);
                sk_pin_set(led_green, true);
                sk_pin_set(led_orange, true);
                sk_pin_set(led_red, true);
                sk_pin_set(led_blue, true);
                softdelay(100000);
                sk_pin_set(led_green, false);
                sk_pin_set(led_orange, false);
                sk_pin_set(led_red, false);
                sk_pin_set(led_blue, false);
        }
}

void exti0_isr(void)
{
        softdelay(200);
        if (sk_pin_read(us_btn))
                mode++;
        // This one removes interrupt request.
        exti_reset_request(EXTI0);
}

int main(void)
{
        rcc_periph_clock_enable(RCC_GPIOA);
        rcc_periph_clock_enable(RCC_GPIOD);
        // Enable EXTI port clock
	// This is not obvious, but selected port is stored in syscfg registers
	rcc_periph_clock_enable(RCC_SYSCFG);

        sk_pin_mode_setup(led_green, MODE_OUTPUT);
        sk_pin_mode_setup(led_orange, MODE_OUTPUT);
        sk_pin_mode_setup(led_red, MODE_OUTPUT);
        sk_pin_mode_setup(led_blue, MODE_OUTPUT);
        sk_pin_mode_setup(us_btn, MODE_INPUT);

        //Set priority group. Programing manual p.228.
        scb_set_priority_grouping(SCB_AIRCR_PRIGROUP_GROUP4_SUB4);
        const uint8_t group = 2;
        const uint8_t subgroup = 0;
        nvic_set_priority(NVIC_EXTI0_IRQ, (group << 2) | subgroup);

        //Select multiplexer EXTI0 and port from which we will wait interrupt.
        exti_select_source(EXTI0, us_btn.port);
        //Set for EXTI0_ISR faling triger register.
        exti_set_trigger(EXTI0, EXTI_TRIGGER_FALLING);
        exti_enable_request(EXTI0);
        // Important: if we don't reset request before interrupt is enabled at NVIC
	//            we will have first "phantom" interrupt request despite no button had been pressed
	exti_reset_request(EXTI0);

        //Enabke interrupt (IRQ);
        nvic_enable_irq(NVIC_EXTI0_IRQ);
        // Globally enable interrupts. Just to show how it's done
        cm_enable_interrupts();

        sk_pin_set(led_green, true);  //led on

        while(1) {
                leds_blinky();
        }
}
